From dc66d1670faec316ce2bf826d35b74ca657f4ce5 Mon Sep 17 00:00:00 2001
From: Bingco <ittat@live.com>
Date: Thu, 23 Apr 2020 14:15:22 +0800
Subject: [PATCH 2/3] Fix to use selinux_status_getenforce().part2

Signed-off-by: ittat <ittat@live.com>
---
 init/service.cpp | 246 +----------------------------------------------
 1 file changed, 2 insertions(+), 244 deletions(-)

diff --git a/init/service.cpp b/init/service.cpp
index ad9a3e0af..531b31e3a 100644
--- a/init/service.cpp
+++ b/init/service.cpp
@@ -40,6 +40,7 @@
 #include <hidl-util/FQName.h>
 #include <processgroup/processgroup.h>
 #include <selinux/selinux.h>
+#include <selinux/avc.h>
 #include <system/thread_defs.h>
 
 #include "rlimit_parser.h"
@@ -1232,247 +1233,4 @@ void Service::StopOrReset(int how) {
     }
     // Make sure it's in right status when a restart immediately follow a
     // stop/reset or vice versa.
-    if (how == SVC_RESTART) {
-        flags_ &= (~(SVC_DISABLED | SVC_RESET));
-    } else {
-        flags_ &= (~SVC_RESTART);
-    }
-
-    if (pid_) {
-        KillProcessGroup(SIGKILL);
-        NotifyStateChange("stopping");
-    } else {
-        NotifyStateChange("stopped");
-    }
-}
-
-void Service::ZapStdio() const {
-    int fd;
-    fd = open("/dev/null", O_RDWR);
-    dup2(fd, 0);
-    dup2(fd, 1);
-    dup2(fd, 2);
-    close(fd);
-}
-
-void Service::OpenConsole() const {
-    int fd = open(console_.c_str(), O_RDWR);
-    if (fd == -1) fd = open("/dev/null", O_RDWR);
-    ioctl(fd, TIOCSCTTY, 0);
-    dup2(fd, 0);
-    dup2(fd, 1);
-    dup2(fd, 2);
-    close(fd);
-}
-
-ServiceList::ServiceList() {}
-
-ServiceList& ServiceList::GetInstance() {
-    static ServiceList instance;
-    return instance;
-}
-
-void ServiceList::AddService(std::unique_ptr<Service> service) {
-    services_.emplace_back(std::move(service));
-}
-
-std::unique_ptr<Service> Service::MakeTemporaryOneshotService(const std::vector<std::string>& args) {
-    // Parse the arguments: exec [SECLABEL [UID [GID]*] --] COMMAND ARGS...
-    // SECLABEL can be a - to denote default
-    std::size_t command_arg = 1;
-    for (std::size_t i = 1; i < args.size(); ++i) {
-        if (args[i] == "--") {
-            command_arg = i + 1;
-            break;
-        }
-    }
-    if (command_arg > 4 + NR_SVC_SUPP_GIDS) {
-        LOG(ERROR) << "exec called with too many supplementary group ids";
-        return nullptr;
-    }
-
-    if (command_arg >= args.size()) {
-        LOG(ERROR) << "exec called without command";
-        return nullptr;
-    }
-    std::vector<std::string> str_args(args.begin() + command_arg, args.end());
-
-    static size_t exec_count = 0;
-    exec_count++;
-    std::string name = "exec " + std::to_string(exec_count) + " (" + Join(str_args, " ") + ")";
-
-    unsigned flags = SVC_ONESHOT | SVC_TEMPORARY;
-    unsigned namespace_flags = 0;
-
-    std::string seclabel = "";
-    if (command_arg > 2 && args[1] != "-") {
-        seclabel = args[1];
-    }
-    Result<uid_t> uid = 0;
-    if (command_arg > 3) {
-        uid = DecodeUid(args[2]);
-        if (!uid) {
-            LOG(ERROR) << "Unable to decode UID for '" << args[2] << "': " << uid.error();
-            return nullptr;
-        }
-    }
-    Result<gid_t> gid = 0;
-    std::vector<gid_t> supp_gids;
-    if (command_arg > 4) {
-        gid = DecodeUid(args[3]);
-        if (!gid) {
-            LOG(ERROR) << "Unable to decode GID for '" << args[3] << "': " << gid.error();
-            return nullptr;
-        }
-        std::size_t nr_supp_gids = command_arg - 1 /* -- */ - 4 /* exec SECLABEL UID GID */;
-        for (size_t i = 0; i < nr_supp_gids; ++i) {
-            auto supp_gid = DecodeUid(args[4 + i]);
-            if (!supp_gid) {
-                LOG(ERROR) << "Unable to decode GID for '" << args[4 + i]
-                           << "': " << supp_gid.error();
-                return nullptr;
-            }
-            supp_gids.push_back(*supp_gid);
-        }
-    }
-
-    return std::make_unique<Service>(name, flags, *uid, *gid, supp_gids, namespace_flags, seclabel,
-                                     nullptr, str_args);
-}
-
-// Shutdown services in the opposite order that they were started.
-const std::vector<Service*> ServiceList::services_in_shutdown_order() const {
-    std::vector<Service*> shutdown_services;
-    for (const auto& service : services_) {
-        if (service->start_order() > 0) shutdown_services.emplace_back(service.get());
-    }
-    std::sort(shutdown_services.begin(), shutdown_services.end(),
-              [](const auto& a, const auto& b) { return a->start_order() > b->start_order(); });
-    return shutdown_services;
-}
-
-void ServiceList::RemoveService(const Service& svc) {
-    auto svc_it = std::find_if(services_.begin(), services_.end(),
-                               [&svc] (const std::unique_ptr<Service>& s) {
-                                   return svc.name() == s->name();
-                               });
-    if (svc_it == services_.end()) {
-        return;
-    }
-
-    services_.erase(svc_it);
-}
-
-void ServiceList::DumpState() const {
-    for (const auto& s : services_) {
-        s->DumpState();
-    }
-}
-
-void ServiceList::MarkPostData() {
-    post_data_ = true;
-}
-
-bool ServiceList::IsPostData() {
-    return post_data_;
-}
-
-void ServiceList::MarkServicesUpdate() {
-    services_update_finished_ = true;
-
-    // start the delayed services
-    for (const auto& name : delayed_service_names_) {
-        Service* service = FindService(name);
-        if (service == nullptr) {
-            LOG(ERROR) << "delayed service '" << name << "' could not be found.";
-            continue;
-        }
-        if (auto result = service->Start(); !result) {
-            LOG(ERROR) << result.error_string();
-        }
-    }
-    delayed_service_names_.clear();
-}
-
-void ServiceList::DelayService(const Service& service) {
-    if (services_update_finished_) {
-        LOG(ERROR) << "Cannot delay the start of service '" << service.name()
-                   << "' because all services are already updated. Ignoring.";
-        return;
-    }
-    delayed_service_names_.emplace_back(service.name());
-}
-
-Result<Success> ServiceParser::ParseSection(std::vector<std::string>&& args,
-                                            const std::string& filename, int line) {
-    if (args.size() < 3) {
-        return Error() << "services must have a name and a program";
-    }
-
-    const std::string& name = args[1];
-    if (!IsValidName(name)) {
-        return Error() << "invalid service name '" << name << "'";
-    }
-
-    filename_ = filename;
-
-    Subcontext* restart_action_subcontext = nullptr;
-    if (subcontexts_) {
-        for (auto& subcontext : *subcontexts_) {
-            if (StartsWith(filename, subcontext.path_prefix())) {
-                restart_action_subcontext = &subcontext;
-                break;
-            }
-        }
-    }
-
-    std::vector<std::string> str_args(args.begin() + 2, args.end());
-
-    if (SelinuxGetVendorAndroidVersion() <= __ANDROID_API_P__) {
-        if (str_args[0] == "/sbin/watchdogd") {
-            str_args[0] = "/system/bin/watchdogd";
-        }
-    }
-
-    service_ = std::make_unique<Service>(name, restart_action_subcontext, str_args);
-    return Success();
-}
-
-Result<Success> ServiceParser::ParseLineSection(std::vector<std::string>&& args, int line) {
-    return service_ ? service_->ParseLine(std::move(args)) : Success();
-}
-
-Result<Success> ServiceParser::EndSection() {
-    if (service_) {
-        Service* old_service = service_list_->FindService(service_->name());
-        if (old_service) {
-            if (!service_->is_override()) {
-                return Error() << "ignored duplicate definition of service '" << service_->name()
-                               << "'";
-            }
-
-            if (StartsWith(filename_, "/apex/") && !old_service->is_updatable()) {
-                return Error() << "cannot update a non-updatable service '" << service_->name()
-                               << "' with a config in APEX";
-            }
-
-            service_list_->RemoveService(*old_service);
-            old_service = nullptr;
-        }
-
-        service_list_->AddService(std::move(service_));
-    }
-
-    return Success();
-}
-
-bool ServiceParser::IsValidName(const std::string& name) const {
-    // Property names can be any length, but may only contain certain characters.
-    // Property values can contain any characters, but may only be a certain length.
-    // (The latter restriction is needed because `start` and `stop` work by writing
-    // the service name to the "ctl.start" and "ctl.stop" properties.)
-    return IsLegalPropertyName("init.svc." + name) && name.size() <= PROP_VALUE_MAX;
-}
-
-}  // namespace init
-}  // namespace android
+    if (how == SVC_RESTART)
-- 
2.17.1

